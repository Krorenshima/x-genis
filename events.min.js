!function(fact){let mw,b,n;null!=this.process&&(b=(x,y)=>({}.toString.call(x).toLowerCase().includes(y)),mw=(name,t)=>b(name,"string")?(module.exports[name]=t,mw):(module.exports=name,mw),n=!0),null!=this.window&&(b=null!=window.pen?pen.type:(x,y)=>({}.toString.call(x).toLowerCase().includes(y)),mw=(name,t)=>(window[name]=t,mw),n=!1),function(mw,type,n){let ev;if(ev=function(){if(!(this instanceof ev))throw new Error("Use 'new' keyword");return this._events={},this.maxListeners=null,this.maxEvents=null,this},ev.prototype={constructor:ev,get length(){let len;len=0;for(let prop in this._events)len++;if(len>this.maxEvents)throw new Error("Possible memory leak detected.");return len},on(ename,efn){if(null==efn)throw new Error("Arg #2 can't be empty");if(this.length>this.maxEvents)return console.warn("Can't go over the limit"),this;if(this.has(ename)){let g,fn;if(g=this.get(ename),0===efn.name.length)throw new Error("The function passed has no name");return null!=g.listeners?g.listeners.length>this.maxListeners?(console.warn("Can't go over the limit"),this):(g.listeners.push(efn),this._events[ename]=g,this):(fn=g.listener,delete g.listener,g.listeners=[],g.listeners.push(fn,efn),this._events[ename]=g,this)}let g=this._events[ename]={};return g.listener=efn,g.once=!1,this._events[ename]=g,this},off(ename,efn){if(!this.has(ename))return console.warn(`No event with name '${name}'`),this;if(this.hasMulti(ename)){if(null!=efn){let evs;evs=this._events[ename].listeners;for(let i=0,len=evs.length;i<len;i++){let t=type(efn,"string")?efn:efn.name;if(0!==evs[i].name&&(evs[i].name===t&&evs[i].name===t)){this._events[ename].listeners.splice(i,1);break}}return this}return delete this._events[ename],this}return this._events[ename].listener=null,this},has(name){return null!=this._events[name]},hasMulti(name){return null!=this._events[name].listeners},get(name){return this.has(name)?this._events[name]:(console.warn(`No event with name '${name}'`),null)},listeners(name){return this.has(name)?this.hasMulti(name)?this.get(name).listeners:this.get(name).listener:(console.warn(`No event with name '${name}'`),null)},once(ename,efn){return this.on(ename,efn),this._events[ename].once=!0,this},emit(name,...args){if(!this.has(name))throw new Error(`No event with name '${name}'`);let g=this.get(name);if(null==g.listener)for(let i=0,len=g.listeners.length;i<len;i++){(0,g.listeners[i])(...args)}else g.listener(...args);return g.once&&delete this._events[name],this}},n)return void mw(ev);mw("events",ev)}(mw,b,n)}();